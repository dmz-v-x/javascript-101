## NaN

## 1. What is NaN?

NaN stands for:

**Not-a-Number**

But here's the first surprise:

> NaN does NOT literally mean “this is not a number type”.

Instead:

> NaN means **invalid numeric result**.

Very important distinction.

NaN appears when:
- JavaScript expects a number
- but calculation fails

Example:

    0 / 0;       // NaN
    Math.sqrt(-1); // NaN

So NaN is:

✔ A number type  
✔ But representing an invalid numeric value

---

## 2. Why `typeof NaN` → "number"?

This confuses EVERY beginner.

    typeof NaN; // "number"

Why?

Because in JavaScript:

✔ NaN belongs to the **Number type**

Internally:
- JavaScript uses IEEE-754 floating point numbers
- NaN is a special numeric value defined by the standard

So:

> NaN is technically a number, just a broken one.

Mental model:

✔ Valid number → 10  
✔ Invalid number → NaN  

Both are numbers.

---

## 3. How is NaN Created?

NaN is produced when numeric operations fail.

---

### Invalid Math

    0 / 0;        // NaN
    Infinity - Infinity; // NaN

---

### Invalid Conversions

    Number("abc"); // NaN

---

### Invalid Calculations

    "hello" * 5;  // NaN

Because:
- multiplication expects numbers
- string cannot be converted

---

## 4. NaN is NOT Equal to Itself (VERY IMPORTANT)

This is one of the **most famous JS weirdnesses**.

    NaN == NaN;   // false
    NaN === NaN;  // false

Why?

Because by definition:

> NaN represents an unknown / invalid numeric result.

And:

> Unknown ≠ Unknown

This follows IEEE-754 rules.

---

### Special Identity Rule

NaN is the **only primitive value** that:

✔ Does NOT equal itself

---

### Fun Trick

    let x = NaN;

    x !== x; // true

This works ONLY for NaN.

---

## 5. NaN and Comparisons

NaN behaves strangely in comparisons.

    NaN > 5;   // false
    NaN < 5;   // false
    NaN >= 5;  // false
    NaN <= 5;  // false

Why?

Because:

> Any comparison involving NaN → false

Except:

    NaN != NaN; // true

---

## 6. NaN in Arithmetic Operations

NaN is **contagious**.

Example:

    NaN + 5;    // NaN
    NaN * 10;   // NaN
    NaN - 1;    // NaN

Rule:

> Any math with NaN → NaN

Because:
- invalid input → invalid result

---

## 7. Detecting NaN (Correct vs Wrong)

Checking NaN is TRICKY.

---

### ❌ Wrong Way

    x === NaN; // ALWAYS false

Because NaN ≠ NaN.

---

### ⚠️ Global isNaN()

    isNaN("abc"); // true

Why???

Because:

✔ isNaN() performs coercion first

Flow:

    Number("abc") → NaN → true

So:

> isNaN checks “will this become NaN after conversion?”

NOT “is this actually NaN?”

---

## 8. The isNaN() Problem (Very Important)

Example:

    isNaN("hello"); // true
    isNaN(true);    // false
    isNaN(null);    // false

Because coercion:

    Number(true) → 1
    Number(null) → 0

This makes isNaN unreliable.

---

## 9. ✅ Correct Way → Number.isNaN()

    Number.isNaN(NaN);    // true
    Number.isNaN("abc");  // false
    Number.isNaN(10);     // false

Why better?

✔ No coercion  
✔ Strict check  
✔ Predictable behavior  

---

## 10. Safe NaN Check Pattern

Classic safe check:

    (typeof x === "number") && Number.isNaN(x)

Alternative trick:

    x !== x   // ONLY true for NaN

But less readable.

---

## 11. Lesser-Known NaN Gotchas

---

### NaN in Arrays

    [NaN].indexOf(NaN); // -1 ❌

Why?

Because indexOf uses `===`

---

### ✅ includes() Works

    [NaN].includes(NaN); // true ✅

Because includes uses SameValueZero comparison.

---

### JSON Behavior

    JSON.stringify(NaN); // "null"

Surprising but valid.

---

### NaN and Object.is()

    Object.is(NaN, NaN); // true ✅

Because Object.is uses different comparison rules.

---

### NaN Propagation

Once NaN enters calculation:

✔ It spreads everywhere

---

## 12. NaN vs Undefined vs Null

Very common confusion.

| Value | Meaning |
|------|----------|
| NaN | Invalid number |
| undefined | Missing value |
| null | Intentional empty value |

NaN is strictly numeric-related.

---

## 13. NaN and isFinite()

    isFinite(NaN); // false

Better:

    Number.isFinite(NaN); // false

---

## 14. Points to Remember

✔ NaN means invalid numeric value  
✔ NaN is of type number  
✔ NaN ≠ NaN  
✔ Comparisons with NaN → false  
✔ Math with NaN → NaN  
✔ isNaN() coerces (dangerous)  
✔ Number.isNaN() is correct  
✔ indexOf fails for NaN  
✔ includes works for NaN  
✔ Object.is(NaN, NaN) → true  
✔ x !== x → NaN trick  
